def solution(n):
    binary = '0' + bin(n)[2:]
    
    i = binary.rfind('1')
    j = binary[:i].rfind('0')
    
    binary = binary[:j] + '10' + binary[i+1:] + binary[j+2:i+1]
        
    return int(binary, 2)

# 이것도 무슨 법칙이 있는건가 싶은데... 그건 모르겠어서 이상하게 풀어봄
# 가장 오른쪽에 있는 0과 그 오른쪽에 있는 1의 위치를 바꾸면 1의 갯수는 같은 다음 큰 수가 됨
# 이 때 예외가 존재하는데, 1) 모든 수가 1인 경우, 2) 가장 우측에 0이 있는 경우
# 1) 초기화 시 가장 좌측에 0을 추가하여 해결
# 2-1) 가장 좌측의 1의 위치를 찾고, 그보다 좌측에 존재하는 0을 찾음
# 2-2) 01 -> 10 으로 바꾸고 뒤에 1들을 뒤로 댕겨야하는데 문자열 더하는 순서를 잘 입력하여 해결

## 그냥 n+1 계속 하면서 1 갯수 같으면 리턴하는 방법을 봄
## 허탈하지만.... 내 방법은 숫자가 아무리 커져도 시간이 같다고... 자기 위로를 한다...